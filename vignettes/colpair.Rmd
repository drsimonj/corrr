---
title: "Beyond correlation"
output: rmarkdown::html_vignette
author: James Laird-Smith
vignette: >
  %\VignetteIndexEntry{Beyond correlation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette introduces `colpair_map()`, which extends the capabilities of 
corrr by giving you the ability to compare the columns of a data frame using 
your choice of function.

```{r setup}
library(corrr)
library(rcompanion)
library(dplyr, warn.conflicts = F)
library(broom)
library(tibble)
```

To see how this works, let's take a few columns from mtcars. 

```{r}
mini_mtcars <- mtcars %>% select(mpg, cyl, disp)

head(mini_mtcars)
```

Using corrr typically starts with a call to `correlate()`:

```{r}
correlate(mini_mtcars)
```

The result is a new data frame where each of the columns in the original data
are compared on the basis of their correlation coefficient.

But the correlation coefficient is just one possible statistic that can be
used for comparing columns with one another.  Using `colpair_map()`, you can
apply your own function for this purpose.

Just like `correlate()`, `colpair_map()` takes a data frame as its first 
argument. The second argument is for the function you wish to apply. 
For example, say that I am interested in covariance values rather
than correlations. These can be found by passing in `cov()` from the stats 
package:

```{r}
cov_df <- colpair_map(mini_mtcars, stats::cov)

cov_df
```

The resulting data frame behaves just like one returned by `correlate()`, 
except that it is populated with covariance values rather than correlations.
We can still use `shave()` for example to remove duplication, which will
set the upper triangle of values to `NA`.

```{r}
cov_df %>% 
  shave()
```

Similarly, we can still use `stretch()` to get the resulting data frame into a 
longer format:

```{r}
cov_df %>% 
  shave() %>% 
  stretch(na.rm = T)
```

The first part of the name (`colpair_`) comes from the fact that we are 
comparing pairs of columns. The second part of the name (`_map`) is designed to 
evoke the same ideas as purrr's family of map functions,
which iterate over a set of elements, applying a function to each of them.
In this case, `colpair_map()` is iterating over each possible pair of columns 
and applying a function to each pairing.

As such, any function passed to `colpair_map()` must accept a vector for both
its first and second argument. To illustrate, let's say we wanted to run
a series t-tests to see which of our variables are significantly related to 
one another. We can write a function do this like so:

```{r}
calc_ttest_p_value <- function(vec_a, vec_b){
  t.test(vec_a, vec_b)$p.value
}
```

The function returns the t-test's p-value. The two arguments to the function
are the vectors being compared. To demonstrate how this works, let's first run 
the function on each pair of columns individually.

```{r}
calc_ttest_p_value(mini_mtcars[, "mpg"], mini_mtcars[, "cyl"])
calc_ttest_p_value(mini_mtcars[, "mpg"], mini_mtcars[, "disp"])
calc_ttest_p_value(mini_mtcars[, "cyl"], mini_mtcars[, "disp"])
```

As you can see, this is tedious and involves a lot of repeated code.
But `colpair_map()` lets us do this for all column pairings at once and the
output makes the resulting values easy to read.

```{r}
colpair_map(mini_mtcars, calc_ttest_p_value)
```

Having the ability to use arbitrary functions opens up 
intriguing possibilities for analyzing data. One limitation of using only
correlation is that it will only work for continuous variables. With 
`colpair_map()`, we have a way of comparing categorical columns with one 
another. Let's try this with a few categorical columns from dplyr's Star Wars 
data set:

```{r}
mini_star_wars <- dplyr::starwars %>% select(hair_color, eye_color, skin_color)

head(mini_star_wars)
```

There are a few different ways of finding the strength of the relationship 
between two categorical variables. One useful measure is called Cramer's V, 
which takes on values between 0 and 1 depending on how closely associated the
variables are. The rcompanion package provides an implementation of Cramer's V
which we can make use of.

```{r}
colpair_map(mini_star_wars, rcompanion::cramerV)
```

We now have a useful summary of the relationship between the categorical 
variables in this dataset. We can see, the strongest 
relationship is between skin color and eye color.

`colpair_map()` will allow you pass additional arguments to the called 
function via the dots (`...`). For example, the `cramerV()` function 
will allow you to specify the number of decimal places to round the results 
using `digits =`. Let's instead pass this option in via the dots:

```{r}
colpair_map(mini_star_wars, rcompanion::cramerV, digits = 1)
```

Let's now see an example of a fuller analysis pipeline on all the categorical
variables in `starwars` except the characters` names.

```{r}
dplyr::starwars %>% 
  select(where(is.character)) %>% 
  select(-name) %>% 
  colpair_map(rcompanion::cramerV) %>% 
  shave() %>%
  stretch(na.rm = T) %>%
  arrange(desc(r))
```

This vignette has introduced `colpair_map()`, which provides a way to compare 
the columns of a data frame using the values calculated from an arbitrary 
function. This has included examples such as covariance and Cramer's V, the 
latter of which allows for comparisons between categorical variables.

